// Code generated by generate. DO NOT EDIT.

package dashparser

import (
	"bytes"
	"encoding/xml"
	"strconv"
	"strings"
	"time"
)

type AdaptationSetType struct {
	Items                     []string               `xml:",any"`
	FramePacking              []DescriptorType       `xml:"urn:mpeg:dash:schema:mpd:2011 FramePacking,omitempty"`
	AudioChannelConfiguration []DescriptorType       `xml:"urn:mpeg:dash:schema:mpd:2011 AudioChannelConfiguration,omitempty"`
	ContentProtection         []DescriptorType       `xml:"urn:mpeg:dash:schema:mpd:2011 ContentProtection,omitempty"`
	EssentialProperty         []DescriptorType       `xml:"urn:mpeg:dash:schema:mpd:2011 EssentialProperty,omitempty"`
	SupplementalProperty      []DescriptorType       `xml:"urn:mpeg:dash:schema:mpd:2011 SupplementalProperty,omitempty"`
	InbandEventStream         []EventStreamType      `xml:"urn:mpeg:dash:schema:mpd:2011 InbandEventStream,omitempty"`
	Accessibility             []DescriptorType       `xml:"urn:mpeg:dash:schema:mpd:2011 Accessibility,omitempty"`
	Role                      []DescriptorType       `xml:"urn:mpeg:dash:schema:mpd:2011 Role,omitempty"`
	Rating                    []DescriptorType       `xml:"urn:mpeg:dash:schema:mpd:2011 Rating,omitempty"`
	Viewpoint                 []DescriptorType       `xml:"urn:mpeg:dash:schema:mpd:2011 Viewpoint,omitempty"`
	ContentComponent          []ContentComponentType `xml:"urn:mpeg:dash:schema:mpd:2011 ContentComponent,omitempty"`
	BaseURL                   []BaseURLType          `xml:"urn:mpeg:dash:schema:mpd:2011 BaseURL,omitempty"`
	SegmentBase               SegmentBaseType        `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentBase,omitempty"`
	SegmentList               SegmentListType        `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentList,omitempty"`
	SegmentTemplate           SegmentTemplateType    `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentTemplate,omitempty"`
	Representation            []RepresentationType   `xml:"urn:mpeg:dash:schema:mpd:2011 Representation,omitempty"`
	Href                      string                 `xml:"href,attr,omitempty"`
	Actuate                   string                 `xml:"actuate,attr,omitempty"`
	Id                        uint                   `xml:"id,attr,omitempty"`
	Group                     uint                   `xml:"group,attr,omitempty"`
	Lang                      string                 `xml:"lang,attr,omitempty"`
	ContentType               string                 `xml:"contentType,attr,omitempty"`
	Par                       RatioType              `xml:"par,attr,omitempty"`
	MinBandwidth              uint                   `xml:"minBandwidth,attr,omitempty"`
	MaxBandwidth              uint                   `xml:"maxBandwidth,attr,omitempty"`
	MinWidth                  uint                   `xml:"minWidth,attr,omitempty"`
	MaxWidth                  uint                   `xml:"maxWidth,attr,omitempty"`
	MinHeight                 uint                   `xml:"minHeight,attr,omitempty"`
	MaxHeight                 uint                   `xml:"maxHeight,attr,omitempty"`
	MinFrameRate              FrameRateType          `xml:"minFrameRate,attr,omitempty"`
	MaxFrameRate              FrameRateType          `xml:"maxFrameRate,attr,omitempty"`
	SegmentAlignment          ConditionalUintType    `xml:"segmentAlignment,attr,omitempty"`
	SubsegmentAlignment       ConditionalUintType    `xml:"subsegmentAlignment,attr,omitempty"`
	SubsegmentStartsWithSAP   uint                   `xml:"subsegmentStartsWithSAP,attr,omitempty"`
	BitstreamSwitching        bool                   `xml:"bitstreamSwitching,attr,omitempty"`
	Profiles                  string                 `xml:"profiles,attr,omitempty"`
	Width                     uint                   `xml:"width,attr,omitempty"`
	Height                    uint                   `xml:"height,attr,omitempty"`
	Sar                       RatioType              `xml:"sar,attr,omitempty"`
	FrameRate                 FrameRateType          `xml:"frameRate,attr,omitempty"`
	AudioSamplingRate         string                 `xml:"audioSamplingRate,attr,omitempty"`
	MimeType                  string                 `xml:"mimeType,attr,omitempty"`
	SegmentProfiles           string                 `xml:"segmentProfiles,attr,omitempty"`
	Codecs                    string                 `xml:"codecs,attr,omitempty"`
	MaximumSAPPeriod          float64                `xml:"maximumSAPPeriod,attr,omitempty"`
	StartWithSAP              uint                   `xml:"startWithSAP,attr,omitempty"`
	MaxPlayoutRate            float64                `xml:"maxPlayoutRate,attr,omitempty"`
	CodingDependency          bool                   `xml:"codingDependency,attr,omitempty"`
	ScanType                  VideoScanType          `xml:"scanType,attr,omitempty"`
}

func (t *AdaptationSetType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T AdaptationSetType
	var overlay struct {
		*T
		Actuate                 *string              `xml:"actuate,attr,omitempty"`
		SegmentAlignment        *ConditionalUintType `xml:"segmentAlignment,attr,omitempty"`
		SubsegmentAlignment     *ConditionalUintType `xml:"subsegmentAlignment,attr,omitempty"`
		SubsegmentStartsWithSAP *uint                `xml:"subsegmentStartsWithSAP,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Actuate = (*string)(&overlay.T.Actuate)
	overlay.SegmentAlignment = (*ConditionalUintType)(&overlay.T.SegmentAlignment)
	overlay.SubsegmentAlignment = (*ConditionalUintType)(&overlay.T.SubsegmentAlignment)
	overlay.SubsegmentStartsWithSAP = (*uint)(&overlay.T.SubsegmentStartsWithSAP)
	return d.DecodeElement(&overlay, &start)
}

type BaseURLType struct {
	Value                    string  `xml:",chardata"`
	ServiceLocation          string  `xml:"serviceLocation,attr,omitempty"`
	ByteRange                string  `xml:"byteRange,attr,omitempty"`
	AvailabilityTimeOffset   float64 `xml:"availabilityTimeOffset,attr,omitempty"`
	AvailabilityTimeComplete bool    `xml:"availabilityTimeComplete,attr,omitempty"`
}

type ConditionalUintType string

type ContentComponentType struct {
	Items         []string         `xml:",any"`
	Accessibility []DescriptorType `xml:"urn:mpeg:dash:schema:mpd:2011 Accessibility,omitempty"`
	Role          []DescriptorType `xml:"urn:mpeg:dash:schema:mpd:2011 Role,omitempty"`
	Rating        []DescriptorType `xml:"urn:mpeg:dash:schema:mpd:2011 Rating,omitempty"`
	Viewpoint     []DescriptorType `xml:"urn:mpeg:dash:schema:mpd:2011 Viewpoint,omitempty"`
	Id            uint             `xml:"id,attr,omitempty"`
	Lang          string           `xml:"lang,attr,omitempty"`
	ContentType   string           `xml:"contentType,attr,omitempty"`
	Par           RatioType        `xml:"par,attr,omitempty"`
}

type DescriptorType struct {
	Items       []string `xml:",any"`
	SchemeIdUri string   `xml:"schemeIdUri,attr"`
	Value       string   `xml:"value,attr,omitempty"`
	Id          string   `xml:"id,attr,omitempty"`
}

type EventStreamType struct {
	Items       []string    `xml:",any"`
	Event       []EventType `xml:"urn:mpeg:dash:schema:mpd:2011 Event,omitempty"`
	Href        string      `xml:"href,attr,omitempty"`
	Actuate     string      `xml:"actuate,attr,omitempty"`
	SchemeIdUri string      `xml:"schemeIdUri,attr"`
	Value       string      `xml:"value,attr,omitempty"`
	Timescale   uint        `xml:"timescale,attr,omitempty"`
}

func (t *EventStreamType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T EventStreamType
	var overlay struct {
		*T
		Actuate *string `xml:"actuate,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Actuate = (*string)(&overlay.T.Actuate)
	return d.DecodeElement(&overlay, &start)
}

type EventType struct {
	Items            []string `xml:",any"`
	PresentationTime uint64   `xml:"presentationTime,attr,omitempty"`
	Duration         uint64   `xml:"duration,attr,omitempty"`
	Id               uint     `xml:"id,attr,omitempty"`
	MessageData      string   `xml:"messageData,attr,omitempty"`
}

func (t *EventType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T EventType
	var overlay struct {
		*T
		PresentationTime *uint64 `xml:"presentationTime,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.PresentationTime = (*uint64)(&overlay.T.PresentationTime)
	return d.DecodeElement(&overlay, &start)
}

// Must match the pattern [0-9]*[0-9](/[0-9]*[0-9])?
type FrameRateType string

type MPDtype struct {
	Items                      []string                 `xml:",any"`
	ProgramInformation         []ProgramInformationType `xml:"urn:mpeg:dash:schema:mpd:2011 ProgramInformation,omitempty"`
	BaseURL                    []BaseURLType            `xml:"urn:mpeg:dash:schema:mpd:2011 BaseURL,omitempty"`
	Location                   []string                 `xml:"urn:mpeg:dash:schema:mpd:2011 Location,omitempty"`
	Period                     []PeriodType             `xml:"urn:mpeg:dash:schema:mpd:2011 Period"`
	Metrics                    []MetricsType            `xml:"urn:mpeg:dash:schema:mpd:2011 Metrics,omitempty"`
	EssentialProperty          []DescriptorType         `xml:"urn:mpeg:dash:schema:mpd:2011 EssentialProperty,omitempty"`
	SupplementalProperty       []DescriptorType         `xml:"urn:mpeg:dash:schema:mpd:2011 SupplementalProperty,omitempty"`
	UTCTiming                  []DescriptorType         `xml:"urn:mpeg:dash:schema:mpd:2011 UTCTiming,omitempty"`
	Id                         string                   `xml:"id,attr,omitempty"`
	Profiles                   string                   `xml:"profiles,attr"`
	Type                       PresentationType         `xml:"type,attr,omitempty"`
	AvailabilityStartTime      time.Time                `xml:"availabilityStartTime,attr,omitempty"`
	AvailabilityEndTime        time.Time                `xml:"availabilityEndTime,attr,omitempty"`
	PublishTime                time.Time                `xml:"publishTime,attr,omitempty"`
	MediaPresentationDuration  string                   `xml:"mediaPresentationDuration,attr,omitempty"`
	MinimumUpdatePeriod        string                   `xml:"minimumUpdatePeriod,attr,omitempty"`
	MinBufferTime              string                   `xml:"minBufferTime,attr"`
	TimeShiftBufferDepth       string                   `xml:"timeShiftBufferDepth,attr,omitempty"`
	SuggestedPresentationDelay string                   `xml:"suggestedPresentationDelay,attr,omitempty"`
	MaxSegmentDuration         string                   `xml:"maxSegmentDuration,attr,omitempty"`
	MaxSubsegmentDuration      string                   `xml:"maxSubsegmentDuration,attr,omitempty"`
}

func (t *MPDtype) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T MPDtype
	var layout struct {
		*T
		AvailabilityStartTime *xsdDateTime `xml:"availabilityStartTime,attr,omitempty"`
		AvailabilityEndTime   *xsdDateTime `xml:"availabilityEndTime,attr,omitempty"`
		PublishTime           *xsdDateTime `xml:"publishTime,attr,omitempty"`
	}
	layout.T = (*T)(t)
	layout.AvailabilityStartTime = (*xsdDateTime)(&layout.T.AvailabilityStartTime)
	layout.AvailabilityEndTime = (*xsdDateTime)(&layout.T.AvailabilityEndTime)
	layout.PublishTime = (*xsdDateTime)(&layout.T.PublishTime)
	return e.EncodeElement(layout, start)
}
func (t *MPDtype) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T MPDtype
	var overlay struct {
		*T
		Type                  *PresentationType `xml:"type,attr,omitempty"`
		AvailabilityStartTime *xsdDateTime      `xml:"availabilityStartTime,attr,omitempty"`
		AvailabilityEndTime   *xsdDateTime      `xml:"availabilityEndTime,attr,omitempty"`
		PublishTime           *xsdDateTime      `xml:"publishTime,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Type = (*PresentationType)(&overlay.T.Type)
	overlay.AvailabilityStartTime = (*xsdDateTime)(&overlay.T.AvailabilityStartTime)
	overlay.AvailabilityEndTime = (*xsdDateTime)(&overlay.T.AvailabilityEndTime)
	overlay.PublishTime = (*xsdDateTime)(&overlay.T.PublishTime)
	return d.DecodeElement(&overlay, &start)
}

type MetricsType struct {
	Items     []string         `xml:",any"`
	Reporting []DescriptorType `xml:"urn:mpeg:dash:schema:mpd:2011 Reporting"`
	Range     []RangeType      `xml:"urn:mpeg:dash:schema:mpd:2011 Range,omitempty"`
	Metrics   string           `xml:"metrics,attr"`
}

type MultipleSegmentBaseType struct {
	Items                    []string            `xml:",any"`
	Initialization           URLType             `xml:"urn:mpeg:dash:schema:mpd:2011 Initialization,omitempty"`
	RepresentationIndex      URLType             `xml:"urn:mpeg:dash:schema:mpd:2011 RepresentationIndex,omitempty"`
	SegmentTimeline          SegmentTimelineType `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentTimeline,omitempty"`
	BitstreamSwitching       URLType             `xml:"urn:mpeg:dash:schema:mpd:2011 BitstreamSwitching,omitempty"`
	Duration                 uint                `xml:"duration,attr,omitempty"`
	StartNumber              uint                `xml:"startNumber,attr,omitempty"`
	Timescale                uint                `xml:"timescale,attr,omitempty"`
	PresentationTimeOffset   uint64              `xml:"presentationTimeOffset,attr,omitempty"`
	IndexRange               string              `xml:"indexRange,attr,omitempty"`
	IndexRangeExact          bool                `xml:"indexRangeExact,attr,omitempty"`
	AvailabilityTimeOffset   float64             `xml:"availabilityTimeOffset,attr,omitempty"`
	AvailabilityTimeComplete bool                `xml:"availabilityTimeComplete,attr,omitempty"`
}

func (t *MultipleSegmentBaseType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T MultipleSegmentBaseType
	var overlay struct {
		*T
		IndexRangeExact *bool `xml:"indexRangeExact,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.IndexRangeExact = (*bool)(&overlay.T.IndexRangeExact)
	return d.DecodeElement(&overlay, &start)
}

type PeriodType struct {
	Items                []string            `xml:",any"`
	BaseURL              []BaseURLType       `xml:"urn:mpeg:dash:schema:mpd:2011 BaseURL,omitempty"`
	SegmentBase          SegmentBaseType     `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentBase,omitempty"`
	SegmentList          SegmentListType     `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentList,omitempty"`
	SegmentTemplate      SegmentTemplateType `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentTemplate,omitempty"`
	AssetIdentifier      DescriptorType      `xml:"urn:mpeg:dash:schema:mpd:2011 AssetIdentifier,omitempty"`
	EventStream          []EventStreamType   `xml:"urn:mpeg:dash:schema:mpd:2011 EventStream,omitempty"`
	AdaptationSet        []AdaptationSetType `xml:"urn:mpeg:dash:schema:mpd:2011 AdaptationSet,omitempty"`
	Subset               []SubsetType        `xml:"urn:mpeg:dash:schema:mpd:2011 Subset,omitempty"`
	SupplementalProperty []DescriptorType    `xml:"urn:mpeg:dash:schema:mpd:2011 SupplementalProperty,omitempty"`
	Href                 string              `xml:"href,attr,omitempty"`
	Actuate              string              `xml:"actuate,attr,omitempty"`
	Id                   string              `xml:"id,attr,omitempty"`
	Start                string              `xml:"start,attr,omitempty"`
	Duration             string              `xml:"duration,attr,omitempty"`
	BitstreamSwitching   bool                `xml:"bitstreamSwitching,attr,omitempty"`
}

func (t *PeriodType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T PeriodType
	var overlay struct {
		*T
		Actuate            *string `xml:"actuate,attr,omitempty"`
		BitstreamSwitching *bool   `xml:"bitstreamSwitching,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Actuate = (*string)(&overlay.T.Actuate)
	overlay.BitstreamSwitching = (*bool)(&overlay.T.BitstreamSwitching)
	return d.DecodeElement(&overlay, &start)
}

// May be one of static, dynamic
type PresentationType string

type ProgramInformationType struct {
	Items              []string `xml:",any"`
	Title              string   `xml:"urn:mpeg:dash:schema:mpd:2011 Title,omitempty"`
	Source             string   `xml:"urn:mpeg:dash:schema:mpd:2011 Source,omitempty"`
	Copyright          string   `xml:"urn:mpeg:dash:schema:mpd:2011 Copyright,omitempty"`
	Lang               string   `xml:"lang,attr,omitempty"`
	MoreInformationURL string   `xml:"moreInformationURL,attr,omitempty"`
}

type RangeType struct {
	Starttime string `xml:"starttime,attr,omitempty"`
	Duration  string `xml:"duration,attr,omitempty"`
}

// Must match the pattern [0-9]*:[0-9]*
type RatioType string

type RepresentationBaseType struct {
	Items                     []string          `xml:",any"`
	FramePacking              []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 FramePacking,omitempty"`
	AudioChannelConfiguration []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 AudioChannelConfiguration,omitempty"`
	ContentProtection         []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 ContentProtection,omitempty"`
	EssentialProperty         []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 EssentialProperty,omitempty"`
	SupplementalProperty      []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 SupplementalProperty,omitempty"`
	InbandEventStream         []EventStreamType `xml:"urn:mpeg:dash:schema:mpd:2011 InbandEventStream,omitempty"`
	Profiles                  string            `xml:"profiles,attr,omitempty"`
	Width                     uint              `xml:"width,attr,omitempty"`
	Height                    uint              `xml:"height,attr,omitempty"`
	Sar                       RatioType         `xml:"sar,attr,omitempty"`
	FrameRate                 FrameRateType     `xml:"frameRate,attr,omitempty"`
	AudioSamplingRate         string            `xml:"audioSamplingRate,attr,omitempty"`
	MimeType                  string            `xml:"mimeType,attr,omitempty"`
	SegmentProfiles           string            `xml:"segmentProfiles,attr,omitempty"`
	Codecs                    string            `xml:"codecs,attr,omitempty"`
	MaximumSAPPeriod          float64           `xml:"maximumSAPPeriod,attr,omitempty"`
	StartWithSAP              uint              `xml:"startWithSAP,attr,omitempty"`
	MaxPlayoutRate            float64           `xml:"maxPlayoutRate,attr,omitempty"`
	CodingDependency          bool              `xml:"codingDependency,attr,omitempty"`
	ScanType                  VideoScanType     `xml:"scanType,attr,omitempty"`
}

type RepresentationType struct {
	Items                     []string                `xml:",any"`
	FramePacking              []DescriptorType        `xml:"urn:mpeg:dash:schema:mpd:2011 FramePacking,omitempty"`
	AudioChannelConfiguration []DescriptorType        `xml:"urn:mpeg:dash:schema:mpd:2011 AudioChannelConfiguration,omitempty"`
	ContentProtection         []DescriptorType        `xml:"urn:mpeg:dash:schema:mpd:2011 ContentProtection,omitempty"`
	EssentialProperty         []DescriptorType        `xml:"urn:mpeg:dash:schema:mpd:2011 EssentialProperty,omitempty"`
	SupplementalProperty      []DescriptorType        `xml:"urn:mpeg:dash:schema:mpd:2011 SupplementalProperty,omitempty"`
	InbandEventStream         []EventStreamType       `xml:"urn:mpeg:dash:schema:mpd:2011 InbandEventStream,omitempty"`
	BaseURL                   []BaseURLType           `xml:"urn:mpeg:dash:schema:mpd:2011 BaseURL,omitempty"`
	SubRepresentation         []SubRepresentationType `xml:"urn:mpeg:dash:schema:mpd:2011 SubRepresentation,omitempty"`
	SegmentBase               SegmentBaseType         `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentBase,omitempty"`
	SegmentList               SegmentListType         `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentList,omitempty"`
	SegmentTemplate           SegmentTemplateType     `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentTemplate,omitempty"`
	Id                        StringNoWhitespaceType  `xml:"id,attr"`
	Bandwidth                 uint                    `xml:"bandwidth,attr"`
	QualityRanking            uint                    `xml:"qualityRanking,attr,omitempty"`
	DependencyId              StringVectorType        `xml:"dependencyId,attr,omitempty"`
	MediaStreamStructureId    StringVectorType        `xml:"mediaStreamStructureId,attr,omitempty"`
	Profiles                  string                  `xml:"profiles,attr,omitempty"`
	Width                     uint                    `xml:"width,attr,omitempty"`
	Height                    uint                    `xml:"height,attr,omitempty"`
	Sar                       RatioType               `xml:"sar,attr,omitempty"`
	FrameRate                 FrameRateType           `xml:"frameRate,attr,omitempty"`
	AudioSamplingRate         string                  `xml:"audioSamplingRate,attr,omitempty"`
	MimeType                  string                  `xml:"mimeType,attr,omitempty"`
	SegmentProfiles           string                  `xml:"segmentProfiles,attr,omitempty"`
	Codecs                    string                  `xml:"codecs,attr,omitempty"`
	MaximumSAPPeriod          float64                 `xml:"maximumSAPPeriod,attr,omitempty"`
	StartWithSAP              uint                    `xml:"startWithSAP,attr,omitempty"`
	MaxPlayoutRate            float64                 `xml:"maxPlayoutRate,attr,omitempty"`
	CodingDependency          bool                    `xml:"codingDependency,attr,omitempty"`
	ScanType                  VideoScanType           `xml:"scanType,attr,omitempty"`
}

type S struct {
	T uint64 `xml:"t,attr,omitempty"`
	N uint64 `xml:"n,attr,omitempty"`
	D uint64 `xml:"d,attr"`
	R int    `xml:"r,attr,omitempty"`
}

func (t *S) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T S
	var overlay struct {
		*T
		R *int `xml:"r,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.R = (*int)(&overlay.T.R)
	return d.DecodeElement(&overlay, &start)
}

type SegmentBaseType struct {
	Items                    []string `xml:",any"`
	Initialization           URLType  `xml:"urn:mpeg:dash:schema:mpd:2011 Initialization,omitempty"`
	RepresentationIndex      URLType  `xml:"urn:mpeg:dash:schema:mpd:2011 RepresentationIndex,omitempty"`
	Timescale                uint     `xml:"timescale,attr,omitempty"`
	PresentationTimeOffset   uint64   `xml:"presentationTimeOffset,attr,omitempty"`
	IndexRange               string   `xml:"indexRange,attr,omitempty"`
	IndexRangeExact          bool     `xml:"indexRangeExact,attr,omitempty"`
	AvailabilityTimeOffset   float64  `xml:"availabilityTimeOffset,attr,omitempty"`
	AvailabilityTimeComplete bool     `xml:"availabilityTimeComplete,attr,omitempty"`
}

func (t *SegmentBaseType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SegmentBaseType
	var overlay struct {
		*T
		IndexRangeExact *bool `xml:"indexRangeExact,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.IndexRangeExact = (*bool)(&overlay.T.IndexRangeExact)
	return d.DecodeElement(&overlay, &start)
}

type SegmentListType struct {
	Items                    []string            `xml:",any"`
	Initialization           URLType             `xml:"urn:mpeg:dash:schema:mpd:2011 Initialization,omitempty"`
	RepresentationIndex      URLType             `xml:"urn:mpeg:dash:schema:mpd:2011 RepresentationIndex,omitempty"`
	SegmentTimeline          SegmentTimelineType `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentTimeline,omitempty"`
	BitstreamSwitching       URLType             `xml:"urn:mpeg:dash:schema:mpd:2011 BitstreamSwitching,omitempty"`
	SegmentURL               []SegmentURLType    `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentURL,omitempty"`
	Href                     string              `xml:"href,attr,omitempty"`
	Actuate                  string              `xml:"actuate,attr,omitempty"`
	Duration                 uint                `xml:"duration,attr,omitempty"`
	StartNumber              uint                `xml:"startNumber,attr,omitempty"`
	Timescale                uint                `xml:"timescale,attr,omitempty"`
	PresentationTimeOffset   uint64              `xml:"presentationTimeOffset,attr,omitempty"`
	IndexRange               string              `xml:"indexRange,attr,omitempty"`
	IndexRangeExact          bool                `xml:"indexRangeExact,attr,omitempty"`
	AvailabilityTimeOffset   float64             `xml:"availabilityTimeOffset,attr,omitempty"`
	AvailabilityTimeComplete bool                `xml:"availabilityTimeComplete,attr,omitempty"`
}

func (t *SegmentListType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SegmentListType
	var overlay struct {
		*T
		Actuate         *string `xml:"actuate,attr,omitempty"`
		IndexRangeExact *bool   `xml:"indexRangeExact,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Actuate = (*string)(&overlay.T.Actuate)
	overlay.IndexRangeExact = (*bool)(&overlay.T.IndexRangeExact)
	return d.DecodeElement(&overlay, &start)
}

type SegmentTemplateType struct {
	Items                    []string            `xml:",any"`
	Initialization           URLType             `xml:"urn:mpeg:dash:schema:mpd:2011 Initialization,omitempty"`
	RepresentationIndex      URLType             `xml:"urn:mpeg:dash:schema:mpd:2011 RepresentationIndex,omitempty"`
	SegmentTimeline          SegmentTimelineType `xml:"urn:mpeg:dash:schema:mpd:2011 SegmentTimeline,omitempty"`
	BitstreamSwitching       URLType             `xml:"urn:mpeg:dash:schema:mpd:2011 BitstreamSwitching,omitempty"`
	Media                    string              `xml:"media,attr,omitempty"`
	Index                    string              `xml:"index,attr,omitempty"`
	InitializationAttr       string              `xml:"initialization,attr,omitempty"`
	BitstreamSwitchingAttr   string              `xml:"bitstreamSwitching,attr,omitempty"`
	Duration                 uint                `xml:"duration,attr,omitempty"`
	StartNumber              uint                `xml:"startNumber,attr,omitempty"`
	Timescale                uint                `xml:"timescale,attr,omitempty"`
	PresentationTimeOffset   uint64              `xml:"presentationTimeOffset,attr,omitempty"`
	IndexRange               string              `xml:"indexRange,attr,omitempty"`
	IndexRangeExact          bool                `xml:"indexRangeExact,attr,omitempty"`
	AvailabilityTimeOffset   float64             `xml:"availabilityTimeOffset,attr,omitempty"`
	AvailabilityTimeComplete bool                `xml:"availabilityTimeComplete,attr,omitempty"`
}

func (t *SegmentTemplateType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SegmentTemplateType
	var overlay struct {
		*T
		IndexRangeExact *bool `xml:"indexRangeExact,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.IndexRangeExact = (*bool)(&overlay.T.IndexRangeExact)
	return d.DecodeElement(&overlay, &start)
}

type SegmentTimelineType struct {
	Items []string `xml:",any"`
	S     []S      `xml:"urn:mpeg:dash:schema:mpd:2011 S"`
}

type SegmentURLType struct {
	Items      []string `xml:",any"`
	Media      string   `xml:"media,attr,omitempty"`
	MediaRange string   `xml:"mediaRange,attr,omitempty"`
	Index      string   `xml:"index,attr,omitempty"`
	IndexRange string   `xml:"indexRange,attr,omitempty"`
}

// Must match the pattern [^\r\n\t \p{Z}]*
type StringNoWhitespaceType string

type StringVectorType []string

func (x *StringVectorType) MarshalText() ([]byte, error) {
	result := make([][]byte, 0, len(*x))
	for _, v := range *x {
		result = append(result, []byte(v))
	}
	return bytes.Join(result, []byte(" ")), nil
}
func (x *StringVectorType) UnmarshalText(text []byte) error {
	for _, v := range bytes.Fields(text) {
		*x = append(*x, string(v))
	}
	return nil
}

type SubRepresentationType struct {
	Items                     []string          `xml:",any"`
	FramePacking              []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 FramePacking,omitempty"`
	AudioChannelConfiguration []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 AudioChannelConfiguration,omitempty"`
	ContentProtection         []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 ContentProtection,omitempty"`
	EssentialProperty         []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 EssentialProperty,omitempty"`
	SupplementalProperty      []DescriptorType  `xml:"urn:mpeg:dash:schema:mpd:2011 SupplementalProperty,omitempty"`
	InbandEventStream         []EventStreamType `xml:"urn:mpeg:dash:schema:mpd:2011 InbandEventStream,omitempty"`
	Level                     uint              `xml:"level,attr,omitempty"`
	DependencyLevel           UIntVectorType    `xml:"dependencyLevel,attr,omitempty"`
	Bandwidth                 uint              `xml:"bandwidth,attr,omitempty"`
	ContentComponent          StringVectorType  `xml:"contentComponent,attr,omitempty"`
	Profiles                  string            `xml:"profiles,attr,omitempty"`
	Width                     uint              `xml:"width,attr,omitempty"`
	Height                    uint              `xml:"height,attr,omitempty"`
	Sar                       RatioType         `xml:"sar,attr,omitempty"`
	FrameRate                 FrameRateType     `xml:"frameRate,attr,omitempty"`
	AudioSamplingRate         string            `xml:"audioSamplingRate,attr,omitempty"`
	MimeType                  string            `xml:"mimeType,attr,omitempty"`
	SegmentProfiles           string            `xml:"segmentProfiles,attr,omitempty"`
	Codecs                    string            `xml:"codecs,attr,omitempty"`
	MaximumSAPPeriod          float64           `xml:"maximumSAPPeriod,attr,omitempty"`
	StartWithSAP              uint              `xml:"startWithSAP,attr,omitempty"`
	MaxPlayoutRate            float64           `xml:"maxPlayoutRate,attr,omitempty"`
	CodingDependency          bool              `xml:"codingDependency,attr,omitempty"`
	ScanType                  VideoScanType     `xml:"scanType,attr,omitempty"`
}

type SubsetType struct {
	Contains UIntVectorType `xml:"contains,attr"`
	Id       string         `xml:"id,attr,omitempty"`
}

type UIntVectorType []uint

func (x *UIntVectorType) MarshalText() ([]byte, error) {
	result := make([][]byte, 0, len(*x))
	for _, v := range *x {
		result = append(result, []byte(strconv.FormatUint(uint64(v), 10)))
	}
	return bytes.Join(result, []byte(" ")), nil
}
func (x *UIntVectorType) UnmarshalText(text []byte) error {
	for _, v := range strings.Fields(string(text)) {
		if i, err := strconv.ParseUint(v, 10, 32); err != nil {
			return err
		} else {
			*x = append(*x, uint(i))
		}
	}
	return nil
}

type URLType struct {
	Items     []string `xml:",any"`
	SourceURL string   `xml:"sourceURL,attr,omitempty"`
	Range     string   `xml:"range,attr,omitempty"`
}

// May be one of progressive, interlaced, unknown
type VideoScanType string

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}
